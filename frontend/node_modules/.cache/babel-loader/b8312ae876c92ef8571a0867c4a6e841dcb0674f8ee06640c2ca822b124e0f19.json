{"ast":null,"code":"var _jsxFileName = \"/Users/kei/AIdeator-LLM/frontend/src/components/MindMap.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from 'react';\nimport './MindMap.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MindMap = ({\n  centralQuestion,\n  concepts\n}) => {\n  _s();\n  const [positions, setPositions] = useState({});\n  const [draggedConcept, setDraggedConcept] = useState(null);\n  const [dragOffset, setDragOffset] = useState({\n    x: 0,\n    y: 0\n  });\n  const [activeNodes, setActiveNodes] = useState(concepts.map((_, i) => true));\n  const [nodeRefs, setNodeRefs] = useState({});\n  const mapRef = useRef(null);\n  const centralRef = useRef(null);\n\n  // Create refs for each concept node\n  useEffect(() => {\n    const refs = {};\n    concepts.forEach((_, index) => {\n      refs[`concept-${index}`] = /*#__PURE__*/React.createRef();\n    });\n    setNodeRefs(refs);\n  }, [concepts]);\n\n  // Initialize positions in a circular pattern around the center\n  useEffect(() => {\n    if (Object.keys(positions).length === 0) {\n      const initialPositions = {};\n\n      // Position concepts evenly in a circle around the central question\n      concepts.forEach((_, index) => {\n        const angle = 2 * Math.PI * index / concepts.length;\n        initialPositions[`concept-${index}`] = {\n          x: Math.cos(angle) * 300,\n          y: Math.sin(angle) * 200\n        };\n      });\n      setPositions(initialPositions);\n    }\n  }, [concepts, positions]);\n\n  // Handle starting to drag a concept\n  const handleMouseDown = (e, conceptId) => {\n    e.preventDefault();\n    e.stopPropagation();\n    const rect = e.currentTarget.getBoundingClientRect();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    setDraggedConcept(conceptId);\n    setDragOffset({\n      x: e.clientX - (rect.left - mapRect.left),\n      y: e.clientY - (rect.top - mapRect.top)\n    });\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n  };\n\n  // Handle dragging a concept\n  const handleMouseMove = e => {\n    if (!draggedConcept) return;\n    e.preventDefault();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    const newX = e.clientX - mapRect.left - dragOffset.x;\n    const newY = e.clientY - mapRect.top - dragOffset.y;\n    setPositions(prev => ({\n      ...prev,\n      [draggedConcept]: {\n        x: newX,\n        y: newY\n      }\n    }));\n  };\n\n  // Handle dropping a concept\n  const handleMouseUp = () => {\n    setDraggedConcept(null);\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('mouseup', handleMouseUp);\n  };\n\n  // Toggle active/inactive state of a concept when clicked\n  const handleConceptClick = index => {\n    if (draggedConcept) return; // Don't toggle if we're dragging\n\n    setActiveNodes(prev => {\n      const newActiveNodes = [...prev];\n      newActiveNodes[index] = !newActiveNodes[index];\n      return newActiveNodes;\n    });\n  };\n\n  // Calculate the exact connection points between center and nodes\n  const getConnectionPoints = index => {\n    var _nodeRefs;\n    if (!centralRef.current || !((_nodeRefs = nodeRefs[`concept-${index}`]) !== null && _nodeRefs !== void 0 && _nodeRefs.current)) {\n      return {\n        x1: '50%',\n        y1: '50%',\n        x2: '50%',\n        y2: '50%'\n      };\n    }\n    const centralRect = centralRef.current.getBoundingClientRect();\n    const nodeRect = nodeRefs[`concept-${index}`].current.getBoundingClientRect();\n    const mapRect = mapRef.current.getBoundingClientRect();\n\n    // Center points\n    const centralX = centralRect.left + centralRect.width / 2 - mapRect.left;\n    const centralY = centralRect.top + centralRect.height / 2 - mapRect.top;\n    const nodeX = nodeRect.left + nodeRect.width / 2 - mapRect.left;\n    const nodeY = nodeRect.top + nodeRect.height / 2 - mapRect.top;\n\n    // Calculate angle between centers\n    const angle = Math.atan2(nodeY - centralY, nodeX - centralX);\n\n    // Find edge points\n    const centralWidth = centralRect.width / 2;\n    const centralHeight = centralRect.height / 2;\n    const nodeWidth = nodeRect.width / 2;\n    const nodeHeight = nodeRect.height / 2;\n\n    // Calculate intersection points with rectangles\n    let centralIntersectX, centralIntersectY, nodeIntersectX, nodeIntersectY;\n\n    // Central rectangle intersection\n    if (Math.abs(Math.cos(angle)) * centralHeight > Math.abs(Math.sin(angle)) * centralWidth) {\n      // Intersect with left or right edge\n      centralIntersectX = centralX + Math.sign(Math.cos(angle)) * centralWidth;\n      centralIntersectY = centralY + Math.tan(angle) * Math.sign(Math.cos(angle)) * centralWidth;\n    } else {\n      // Intersect with top or bottom edge\n      centralIntersectX = centralX + Math.cot(angle) * Math.sign(Math.sin(angle)) * centralHeight;\n      centralIntersectY = centralY + Math.sign(Math.sin(angle)) * centralHeight;\n    }\n\n    // Node rectangle intersection (angle is reversed)\n    const reverseAngle = Math.atan2(centralY - nodeY, centralX - nodeX);\n    if (Math.abs(Math.cos(reverseAngle)) * nodeHeight > Math.abs(Math.sin(reverseAngle)) * nodeWidth) {\n      // Intersect with left or right edge\n      nodeIntersectX = nodeX + Math.sign(Math.cos(reverseAngle)) * nodeWidth;\n      nodeIntersectY = nodeY + Math.tan(reverseAngle) * Math.sign(Math.cos(reverseAngle)) * nodeWidth;\n    } else {\n      // Intersect with top or bottom edge\n      nodeIntersectX = nodeX + Math.cot(reverseAngle) * Math.sign(Math.sin(reverseAngle)) * nodeHeight;\n      nodeIntersectY = nodeY + Math.sign(Math.sin(reverseAngle)) * nodeHeight;\n    }\n\n    // For simplicity, we'll use a simple approximation\n    // This approximation works well enough for rectangular boxes\n    return {\n      x1: centralIntersectX || centralX,\n      y1: centralIntersectY || centralY,\n      x2: nodeIntersectX || nodeX,\n      y2: nodeIntersectY || nodeY\n    };\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"mind-map-container\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mind-map\",\n      ref: mapRef,\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"central-question\",\n        ref: centralRef,\n        children: centralQuestion\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 158,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"svg\", {\n        className: \"connections\",\n        children: concepts.map((_, index) => {\n          const pos = positions[`concept-${index}`];\n          if (!pos) return null;\n\n          // Simple line rendering that will be improved by the connection calculation in useEffect\n          return /*#__PURE__*/_jsxDEV(\"line\", {\n            x1: \"50%\",\n            y1: \"50%\",\n            x2: `calc(50% + ${pos.x}px)`,\n            y2: `calc(50% + ${pos.y}px)`,\n            className: !activeNodes[index] ? 'connection inactive' : 'connection'\n          }, `line-${index}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 169,\n            columnNumber: 15\n          }, this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 162,\n        columnNumber: 9\n      }, this), concepts.map((concept, index) => {\n        const pos = positions[`concept-${index}`] || {\n          x: 0,\n          y: 0\n        };\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `concept ${!activeNodes[index] ? 'inactive' : ''} ${draggedConcept === `concept-${index}` ? 'dragging' : ''}`,\n          style: {\n            transform: `translate(calc(50% + ${pos.x}px), calc(50% + ${pos.y}px))`,\n            cursor: draggedConcept === `concept-${index}` ? 'grabbing' : 'grab'\n          },\n          ref: nodeRefs[`concept-${index}`],\n          onMouseDown: e => handleMouseDown(e, `concept-${index}`),\n          onClick: () => handleConceptClick(index),\n          children: concept\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 184,\n          columnNumber: 13\n        }, this);\n      })]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 154,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 153,\n    columnNumber: 5\n  }, this);\n};\n\n// Utility functions for angle calculations\n_s(MindMap, \"mmzHMPskRuPd+PHn8/kcq7xcnOk=\");\n_c = MindMap;\nMath.cot = function (x) {\n  return 1 / Math.tan(x);\n};\nexport default MindMap;\nvar _c;\n$RefreshReg$(_c, \"MindMap\");","map":{"version":3,"names":["React","useState","useRef","useEffect","jsxDEV","_jsxDEV","MindMap","centralQuestion","concepts","_s","positions","setPositions","draggedConcept","setDraggedConcept","dragOffset","setDragOffset","x","y","activeNodes","setActiveNodes","map","_","i","nodeRefs","setNodeRefs","mapRef","centralRef","refs","forEach","index","createRef","Object","keys","length","initialPositions","angle","Math","PI","cos","sin","handleMouseDown","e","conceptId","preventDefault","stopPropagation","rect","currentTarget","getBoundingClientRect","mapRect","current","clientX","left","clientY","top","document","addEventListener","handleMouseMove","handleMouseUp","newX","newY","prev","removeEventListener","handleConceptClick","newActiveNodes","getConnectionPoints","_nodeRefs","x1","y1","x2","y2","centralRect","nodeRect","centralX","width","centralY","height","nodeX","nodeY","atan2","centralWidth","centralHeight","nodeWidth","nodeHeight","centralIntersectX","centralIntersectY","nodeIntersectX","nodeIntersectY","abs","sign","tan","cot","reverseAngle","className","children","ref","fileName","_jsxFileName","lineNumber","columnNumber","pos","concept","style","transform","cursor","onMouseDown","onClick","_c","$RefreshReg$"],"sources":["/Users/kei/AIdeator-LLM/frontend/src/components/MindMap.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\nimport './MindMap.css';\n\nconst MindMap = ({ centralQuestion, concepts }) => {\n  const [positions, setPositions] = useState({});\n  const [draggedConcept, setDraggedConcept] = useState(null);\n  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });\n  const [activeNodes, setActiveNodes] = useState(concepts.map((_, i) => true));\n  const [nodeRefs, setNodeRefs] = useState({});\n  const mapRef = useRef(null);\n  const centralRef = useRef(null);\n\n  // Create refs for each concept node\n  useEffect(() => {\n    const refs = {};\n    concepts.forEach((_, index) => {\n      refs[`concept-${index}`] = React.createRef();\n    });\n    setNodeRefs(refs);\n  }, [concepts]);\n\n  // Initialize positions in a circular pattern around the center\n  useEffect(() => {\n    if (Object.keys(positions).length === 0) {\n      const initialPositions = {};\n      \n      // Position concepts evenly in a circle around the central question\n      concepts.forEach((_, index) => {\n        const angle = (2 * Math.PI * index) / concepts.length;\n        initialPositions[`concept-${index}`] = {\n          x: Math.cos(angle) * 300,\n          y: Math.sin(angle) * 200\n        };\n      });\n      \n      setPositions(initialPositions);\n    }\n  }, [concepts, positions]);\n\n  // Handle starting to drag a concept\n  const handleMouseDown = (e, conceptId) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    const rect = e.currentTarget.getBoundingClientRect();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    \n    setDraggedConcept(conceptId);\n    setDragOffset({\n      x: e.clientX - (rect.left - mapRect.left),\n      y: e.clientY - (rect.top - mapRect.top)\n    });\n    \n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n  };\n\n  // Handle dragging a concept\n  const handleMouseMove = (e) => {\n    if (!draggedConcept) return;\n    \n    e.preventDefault();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    const newX = e.clientX - mapRect.left - dragOffset.x;\n    const newY = e.clientY - mapRect.top - dragOffset.y;\n\n    setPositions(prev => ({\n      ...prev,\n      [draggedConcept]: { x: newX, y: newY }\n    }));\n  };\n\n  // Handle dropping a concept\n  const handleMouseUp = () => {\n    setDraggedConcept(null);\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('mouseup', handleMouseUp);\n  };\n\n  // Toggle active/inactive state of a concept when clicked\n  const handleConceptClick = (index) => {\n    if (draggedConcept) return; // Don't toggle if we're dragging\n    \n    setActiveNodes(prev => {\n      const newActiveNodes = [...prev];\n      newActiveNodes[index] = !newActiveNodes[index];\n      return newActiveNodes;\n    });\n  };\n\n  // Calculate the exact connection points between center and nodes\n  const getConnectionPoints = (index) => {\n    if (!centralRef.current || !nodeRefs[`concept-${index}`]?.current) {\n      return { x1: '50%', y1: '50%', x2: '50%', y2: '50%' };\n    }\n\n    const centralRect = centralRef.current.getBoundingClientRect();\n    const nodeRect = nodeRefs[`concept-${index}`].current.getBoundingClientRect();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    \n    // Center points\n    const centralX = centralRect.left + centralRect.width / 2 - mapRect.left;\n    const centralY = centralRect.top + centralRect.height / 2 - mapRect.top;\n    const nodeX = nodeRect.left + nodeRect.width / 2 - mapRect.left;\n    const nodeY = nodeRect.top + nodeRect.height / 2 - mapRect.top;\n    \n    // Calculate angle between centers\n    const angle = Math.atan2(nodeY - centralY, nodeX - centralX);\n    \n    // Find edge points\n    const centralWidth = centralRect.width / 2;\n    const centralHeight = centralRect.height / 2;\n    const nodeWidth = nodeRect.width / 2;\n    const nodeHeight = nodeRect.height / 2;\n    \n    // Calculate intersection points with rectangles\n    let centralIntersectX, centralIntersectY, nodeIntersectX, nodeIntersectY;\n    \n    // Central rectangle intersection\n    if (Math.abs(Math.cos(angle)) * centralHeight > Math.abs(Math.sin(angle)) * centralWidth) {\n      // Intersect with left or right edge\n      centralIntersectX = centralX + Math.sign(Math.cos(angle)) * centralWidth;\n      centralIntersectY = centralY + Math.tan(angle) * Math.sign(Math.cos(angle)) * centralWidth;\n    } else {\n      // Intersect with top or bottom edge\n      centralIntersectX = centralX + Math.cot(angle) * Math.sign(Math.sin(angle)) * centralHeight;\n      centralIntersectY = centralY + Math.sign(Math.sin(angle)) * centralHeight;\n    }\n    \n    // Node rectangle intersection (angle is reversed)\n    const reverseAngle = Math.atan2(centralY - nodeY, centralX - nodeX);\n    if (Math.abs(Math.cos(reverseAngle)) * nodeHeight > Math.abs(Math.sin(reverseAngle)) * nodeWidth) {\n      // Intersect with left or right edge\n      nodeIntersectX = nodeX + Math.sign(Math.cos(reverseAngle)) * nodeWidth;\n      nodeIntersectY = nodeY + Math.tan(reverseAngle) * Math.sign(Math.cos(reverseAngle)) * nodeWidth;\n    } else {\n      // Intersect with top or bottom edge\n      nodeIntersectX = nodeX + Math.cot(reverseAngle) * Math.sign(Math.sin(reverseAngle)) * nodeHeight;\n      nodeIntersectY = nodeY + Math.sign(Math.sin(reverseAngle)) * nodeHeight;\n    }\n    \n    // For simplicity, we'll use a simple approximation\n    // This approximation works well enough for rectangular boxes\n    return {\n      x1: centralIntersectX || centralX,\n      y1: centralIntersectY || centralY,\n      x2: nodeIntersectX || nodeX,\n      y2: nodeIntersectY || nodeY\n    };\n  };\n\n  return (\n    <div className=\"mind-map-container\">\n      <div \n        className=\"mind-map\" \n        ref={mapRef}\n      >\n        <div className=\"central-question\" ref={centralRef}>\n          {centralQuestion}\n        </div>\n        \n        <svg className=\"connections\">\n          {concepts.map((_, index) => {\n            const pos = positions[`concept-${index}`];\n            if (!pos) return null;\n            \n            // Simple line rendering that will be improved by the connection calculation in useEffect\n            return (\n              <line\n                key={`line-${index}`}\n                x1=\"50%\"\n                y1=\"50%\"\n                x2={`calc(50% + ${pos.x}px)`}\n                y2={`calc(50% + ${pos.y}px)`}\n                className={!activeNodes[index] ? 'connection inactive' : 'connection'}\n              />\n            );\n          })}\n        </svg>\n        \n        {concepts.map((concept, index) => {\n          const pos = positions[`concept-${index}`] || { x: 0, y: 0 };\n          return (\n            <div\n              key={index}\n              className={`concept ${!activeNodes[index] ? 'inactive' : ''} ${draggedConcept === `concept-${index}` ? 'dragging' : ''}`}\n              style={{\n                transform: `translate(calc(50% + ${pos.x}px), calc(50% + ${pos.y}px))`,\n                cursor: draggedConcept === `concept-${index}` ? 'grabbing' : 'grab'\n              }}\n              ref={nodeRefs[`concept-${index}`]}\n              onMouseDown={(e) => handleMouseDown(e, `concept-${index}`)}\n              onClick={() => handleConceptClick(index)}\n            >\n              {concept}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\n// Utility functions for angle calculations\nMath.cot = function(x) { return 1 / Math.tan(x); };\n\nexport default MindMap; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}