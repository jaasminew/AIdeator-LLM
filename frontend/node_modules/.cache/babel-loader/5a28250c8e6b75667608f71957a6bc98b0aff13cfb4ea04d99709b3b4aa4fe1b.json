{"ast":null,"code":"var _jsxFileName = \"/Users/kei/AIdeator-LLM/frontend/src/components/MindMap.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport './MindMap.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MindMap = ({\n  centralQuestion,\n  concepts\n}) => {\n  _s();\n  const [positions, setPositions] = useState({});\n  const [draggedConcept, setDraggedConcept] = useState(null);\n  const [dragOffset, setDragOffset] = useState({\n    x: 0,\n    y: 0\n  });\n  const [activeNodes, setActiveNodes] = useState(concepts.map(() => true));\n  const [expandedNodeIndex, setExpandedNodeIndex] = useState(null);\n  const [expandedConcepts, setExpandedConcepts] = useState([]);\n  const mapRef = useRef(null);\n  const conceptRefs = useRef([]);\n  const centralRef = useRef(null);\n\n  // Initialize refs for concept nodes\n  useEffect(() => {\n    conceptRefs.current = Array(concepts.length).fill().map(() => /*#__PURE__*/React.createRef());\n  }, [concepts.length]);\n\n  // Initialize positions in a balanced layout\n  useEffect(() => {\n    if (Object.keys(positions).length === 0) {\n      // Positions that match the reference image exactly\n      const initialPositions = {\n        'concept-0': {\n          x: 0,\n          y: -180\n        },\n        // Top\n        'concept-1': {\n          x: -280,\n          y: 0\n        },\n        // Left\n        'concept-2': {\n          x: 280,\n          y: 0\n        },\n        // Right\n        'concept-3': {\n          x: -180,\n          y: 200\n        },\n        // Bottom Left\n        'concept-4': {\n          x: 180,\n          y: 200\n        } // Bottom Right\n      };\n      setPositions(initialPositions);\n    }\n  }, [positions]);\n\n  // Expand a node with 5 new child nodes\n  const expandNode = index => {\n    console.log(\"Expanding node\", index);\n    setExpandedNodeIndex(index);\n\n    // Create 5 new concept nodes with shorter names\n    const newConcepts = [\"Concept A\", \"Concept B\", \"Concept C\", \"Concept D\", \"Concept E\"];\n    setExpandedConcepts(newConcepts);\n\n    // Create positions for the new nodes following the parent's side\n    const parentPos = positions[`concept-${index}`];\n    const newPositions = {\n      ...positions\n    };\n\n    // Determine which side the parent node is on relative to the center\n    // This uses the standard layout: top, left, right, bottom-left, bottom-right\n    let direction;\n    if (index === 0) {\n      // Top node - place children above it\n      direction = 'top';\n    } else if (index === 1) {\n      // Left node - place children to the left\n      direction = 'left';\n    } else if (index === 2) {\n      // Right node - place children to the right\n      direction = 'right';\n    } else if (index === 3) {\n      // Bottom Left node - place children below and to the left\n      direction = 'bottom-left';\n    } else if (index === 4) {\n      // Bottom Right node - place children below and to the right\n      direction = 'bottom-right';\n    }\n    console.log(\"Direction for expanded nodes:\", direction);\n\n    // Position nodes based on the parent's position/direction\n    switch (direction) {\n      case 'top':\n        // Arrange horizontally above the parent\n        for (let i = 0; i < newConcepts.length; i++) {\n          const xOffset = (i - 2) * 120; // -240, -120, 0, 120, 240\n          newPositions[`expanded-${index}-${i}`] = {\n            x: parentPos.x + xOffset,\n            y: parentPos.y - 150\n          };\n        }\n        break;\n      case 'left':\n        // Arrange vertically to the left - increase spacing\n        for (let i = 0; i < newConcepts.length; i++) {\n          const yOffset = (i - 2) * 100; // -200, -100, 0, 100, 200\n          newPositions[`expanded-${index}-${i}`] = {\n            x: parentPos.x - 250,\n            y: parentPos.y + yOffset\n          };\n        }\n        break;\n      case 'right':\n        // Arrange vertically to the right - increase spacing\n        for (let i = 0; i < newConcepts.length; i++) {\n          const yOffset = (i - 2) * 100; // -200, -100, 0, 100, 200\n          newPositions[`expanded-${index}-${i}`] = {\n            x: parentPos.x + 250,\n            y: parentPos.y + yOffset\n          };\n        }\n        break;\n      case 'bottom-left':\n        // Arrange horizontally below and to the left\n        for (let i = 0; i < newConcepts.length; i++) {\n          const xOffset = (i - 2) * 120; // -240, -120, 0, 120, 240\n          newPositions[`expanded-${index}-${i}`] = {\n            x: parentPos.x - 100 + xOffset,\n            y: parentPos.y + 150\n          };\n        }\n        break;\n      case 'bottom-right':\n        // Arrange horizontally below and to the right\n        for (let i = 0; i < newConcepts.length; i++) {\n          const xOffset = (i - 2) * 120; // -240, -120, 0, 120, 240\n          newPositions[`expanded-${index}-${i}`] = {\n            x: parentPos.x + 100 + xOffset,\n            y: parentPos.y + 150\n          };\n        }\n        break;\n    }\n    setPositions(newPositions);\n  };\n\n  // Toggle node active state\n  const toggleNodeActive = index => {\n    // Count how many inactive nodes we currently have\n    const inactiveCount = activeNodes.filter(active => !active).length;\n\n    // If this node is already inactive, we can always make it active again\n    if (!activeNodes[index]) {\n      setActiveNodes(prev => {\n        const newActive = [...prev];\n        newActive[index] = true;\n        return newActive;\n      });\n      // If we're activating a node, clear expansion\n      if (expandedNodeIndex !== null) {\n        setExpandedNodeIndex(null);\n        setExpandedConcepts([]);\n      }\n      return;\n    }\n\n    // If this would be the 5th inactive node (all inactive), don't allow it\n    if (inactiveCount === 4) {\n      // Find the only remaining active node (which must be this one)\n      const activeNodeIndices = activeNodes.map((active, i) => active ? i : -1).filter(i => i >= 0);\n      if (activeNodeIndices.length === 1 && activeNodeIndices[0] === index) {\n        console.log(\"Can't deactivate the last node\");\n        return;\n      }\n    }\n\n    // Make this node inactive\n    setActiveNodes(prev => {\n      const newActive = [...prev];\n      newActive[index] = false;\n      return newActive;\n    });\n\n    // Check if we now have 4 inactive nodes (1 active)\n    const newInactiveCount = inactiveCount + 1;\n    if (newInactiveCount === 4) {\n      // Find the one remaining active node\n      const remainingActiveIndex = activeNodes.findIndex((active, i) => active && i !== index);\n      if (remainingActiveIndex !== -1) {\n        // Expand the remaining active node\n        expandNode(remainingActiveIndex);\n      }\n    }\n  };\n\n  // Handle starting to drag a concept\n  const handleMouseDown = (e, conceptId) => {\n    e.preventDefault();\n    e.stopPropagation();\n    const rect = e.currentTarget.getBoundingClientRect();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    setDraggedConcept(conceptId);\n    setDragOffset({\n      x: e.clientX - (rect.left - mapRect.left),\n      y: e.clientY - (rect.top - mapRect.top)\n    });\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n  };\n\n  // Handle dragging a concept\n  const handleMouseMove = e => {\n    if (!draggedConcept) return;\n    e.preventDefault();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    const newX = e.clientX - mapRect.left - dragOffset.x;\n    const newY = e.clientY - mapRect.top - dragOffset.y;\n    setPositions(prev => ({\n      ...prev,\n      [draggedConcept]: {\n        x: newX,\n        y: newY\n      }\n    }));\n  };\n\n  // Handle dropping a concept\n  const handleMouseUp = () => {\n    setDraggedConcept(null);\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('mouseup', handleMouseUp);\n  };\n\n  // Render connection lines between central node and concepts\n  const renderConnections = () => {\n    var _mapRef$current, _centralRef$current;\n    const mapRect = (_mapRef$current = mapRef.current) === null || _mapRef$current === void 0 ? void 0 : _mapRef$current.getBoundingClientRect();\n    const centralRect = (_centralRef$current = centralRef.current) === null || _centralRef$current === void 0 ? void 0 : _centralRef$current.getBoundingClientRect();\n    if (!mapRect || !centralRect) return null;\n\n    // The exact center of the central question box\n    const centerX = mapRect.width / 2;\n    const centerY = mapRect.height / 2;\n    const connections = [];\n\n    // Render connections to main concepts\n    concepts.forEach((_, index) => {\n      const pos = positions[`concept-${index}`];\n      if (!pos) return;\n\n      // Calculate the exact center position of the concept\n      const conceptCenterX = centerX + pos.x;\n      const conceptCenterY = centerY + pos.y;\n      connections.push(/*#__PURE__*/_jsxDEV(\"line\", {\n        x1: centerX,\n        y1: centerY,\n        x2: conceptCenterX,\n        y2: conceptCenterY,\n        className: activeNodes[index] ? 'connection' : 'connection inactive'\n      }, `line-${index}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 252,\n        columnNumber: 9\n      }, this));\n\n      // If this is the expanded node, add connections to expanded concepts\n      if (index === expandedNodeIndex) {\n        expandedConcepts.forEach((_, i) => {\n          const expandedPos = positions[`expanded-${index}-${i}`];\n          if (!expandedPos) return;\n          const expandedX = centerX + expandedPos.x;\n          const expandedY = centerY + expandedPos.y;\n          connections.push(/*#__PURE__*/_jsxDEV(\"line\", {\n            x1: conceptCenterX,\n            y1: conceptCenterY,\n            x2: expandedX,\n            y2: expandedY,\n            className: \"connection expanded\"\n          }, `expanded-line-${index}-${i}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 272,\n            columnNumber: 13\n          }, this));\n        });\n      }\n    });\n    return connections;\n  };\n\n  // Console log for debugging\n  console.log(\"Active nodes:\", activeNodes);\n  console.log(\"Expanded node index:\", expandedNodeIndex);\n  console.log(\"Expanded concepts:\", expandedConcepts);\n  console.log(\"Positions:\", positions);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"mind-map-container\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mind-map\",\n      ref: mapRef,\n      children: [/*#__PURE__*/_jsxDEV(\"svg\", {\n        className: \"connections\",\n        children: mapRef.current && centralRef.current && renderConnections()\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 298,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"central-question\",\n        ref: centralRef,\n        children: centralQuestion\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 303,\n        columnNumber: 9\n      }, this), concepts.map((concept, index) => {\n        const pos = positions[`concept-${index}`] || {\n          x: 0,\n          y: 0\n        };\n        const isDragging = draggedConcept === `concept-${index}`;\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `concept ${!activeNodes[index] ? 'inactive' : ''} ${isDragging ? 'dragging' : ''} ${index === expandedNodeIndex ? 'expanded' : ''}`,\n          style: {\n            top: `calc(50% + ${pos.y}px)`,\n            left: `calc(50% + ${pos.x}px)`,\n            transform: 'translate(-50%, -50%)',\n            cursor: isDragging ? 'grabbing' : 'grab'\n          },\n          ref: conceptRefs.current[index],\n          onMouseDown: e => handleMouseDown(e, `concept-${index}`),\n          onClick: e => {\n            e.stopPropagation();\n            if (!draggedConcept) {\n              toggleNodeActive(index);\n            }\n          },\n          children: concept\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 313,\n          columnNumber: 13\n        }, this);\n      }), expandedNodeIndex !== null && expandedConcepts.map((concept, index) => {\n        const pos = positions[`expanded-${expandedNodeIndex}-${index}`];\n        if (!pos) return null;\n\n        // Add debug border for visibility\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"concept expanded-child\",\n          style: {\n            top: `calc(50% + ${pos.y}px)`,\n            left: `calc(50% + ${pos.x}px)`,\n            transform: 'translate(-50%, -50%)',\n            border: '2px solid #000'\n          },\n          children: concept\n        }, `expanded-${expandedNodeIndex}-${index}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 343,\n          columnNumber: 13\n        }, this);\n      })]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 296,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 295,\n    columnNumber: 5\n  }, this);\n};\n_s(MindMap, \"lUgL2qTVybr7GVwq/gDF27AqFvI=\");\n_c = MindMap;\nexport default MindMap;\nvar _c;\n$RefreshReg$(_c, \"MindMap\");","map":{"version":3,"names":["React","useState","useEffect","useRef","jsxDEV","_jsxDEV","MindMap","centralQuestion","concepts","_s","positions","setPositions","draggedConcept","setDraggedConcept","dragOffset","setDragOffset","x","y","activeNodes","setActiveNodes","map","expandedNodeIndex","setExpandedNodeIndex","expandedConcepts","setExpandedConcepts","mapRef","conceptRefs","centralRef","current","Array","length","fill","createRef","Object","keys","initialPositions","expandNode","index","console","log","newConcepts","parentPos","newPositions","direction","i","xOffset","yOffset","toggleNodeActive","inactiveCount","filter","active","prev","newActive","activeNodeIndices","newInactiveCount","remainingActiveIndex","findIndex","handleMouseDown","e","conceptId","preventDefault","stopPropagation","rect","currentTarget","getBoundingClientRect","mapRect","clientX","left","clientY","top","document","addEventListener","handleMouseMove","handleMouseUp","newX","newY","removeEventListener","renderConnections","_mapRef$current","_centralRef$current","centralRect","centerX","width","centerY","height","connections","forEach","_","pos","conceptCenterX","conceptCenterY","push","x1","y1","x2","y2","className","fileName","_jsxFileName","lineNumber","columnNumber","expandedPos","expandedX","expandedY","children","ref","concept","isDragging","style","transform","cursor","onMouseDown","onClick","border","_c","$RefreshReg$"],"sources":["/Users/kei/AIdeator-LLM/frontend/src/components/MindMap.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport './MindMap.css';\n\nconst MindMap = ({ centralQuestion, concepts }) => {\n  const [positions, setPositions] = useState({});\n  const [draggedConcept, setDraggedConcept] = useState(null);\n  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });\n  const [activeNodes, setActiveNodes] = useState(concepts.map(() => true));\n  const [expandedNodeIndex, setExpandedNodeIndex] = useState(null);\n  const [expandedConcepts, setExpandedConcepts] = useState([]);\n  const mapRef = useRef(null);\n  const conceptRefs = useRef([]);\n  const centralRef = useRef(null);\n\n  // Initialize refs for concept nodes\n  useEffect(() => {\n    conceptRefs.current = Array(concepts.length).fill().map(() => React.createRef());\n  }, [concepts.length]);\n\n  // Initialize positions in a balanced layout\n  useEffect(() => {\n    if (Object.keys(positions).length === 0) {\n      // Positions that match the reference image exactly\n      const initialPositions = {\n        'concept-0': { x: 0, y: -180 },      // Top\n        'concept-1': { x: -280, y: 0 },      // Left\n        'concept-2': { x: 280, y: 0 },       // Right\n        'concept-3': { x: -180, y: 200 },    // Bottom Left\n        'concept-4': { x: 180, y: 200 }      // Bottom Right\n      };\n      \n      setPositions(initialPositions);\n    }\n  }, [positions]);\n\n  // Expand a node with 5 new child nodes\n  const expandNode = (index) => {\n    console.log(\"Expanding node\", index);\n    setExpandedNodeIndex(index);\n    \n    // Create 5 new concept nodes with shorter names\n    const newConcepts = [\n      \"Concept A\",\n      \"Concept B\", \n      \"Concept C\",\n      \"Concept D\",\n      \"Concept E\"\n    ];\n    \n    setExpandedConcepts(newConcepts);\n    \n    // Create positions for the new nodes following the parent's side\n    const parentPos = positions[`concept-${index}`];\n    const newPositions = { ...positions };\n    \n    // Determine which side the parent node is on relative to the center\n    // This uses the standard layout: top, left, right, bottom-left, bottom-right\n    let direction;\n    \n    if (index === 0) {\n      // Top node - place children above it\n      direction = 'top';\n    } else if (index === 1) {\n      // Left node - place children to the left\n      direction = 'left';\n    } else if (index === 2) {\n      // Right node - place children to the right\n      direction = 'right';\n    } else if (index === 3) {\n      // Bottom Left node - place children below and to the left\n      direction = 'bottom-left';\n    } else if (index === 4) {\n      // Bottom Right node - place children below and to the right\n      direction = 'bottom-right';\n    }\n    \n    console.log(\"Direction for expanded nodes:\", direction);\n    \n    // Position nodes based on the parent's position/direction\n    switch (direction) {\n      case 'top':\n        // Arrange horizontally above the parent\n        for (let i = 0; i < newConcepts.length; i++) {\n          const xOffset = (i - 2) * 120; // -240, -120, 0, 120, 240\n          newPositions[`expanded-${index}-${i}`] = {\n            x: parentPos.x + xOffset,\n            y: parentPos.y - 150\n          };\n        }\n        break;\n        \n      case 'left':\n        // Arrange vertically to the left - increase spacing\n        for (let i = 0; i < newConcepts.length; i++) {\n          const yOffset = (i - 2) * 100; // -200, -100, 0, 100, 200\n          newPositions[`expanded-${index}-${i}`] = {\n            x: parentPos.x - 250,\n            y: parentPos.y + yOffset\n          };\n        }\n        break;\n        \n      case 'right':\n        // Arrange vertically to the right - increase spacing\n        for (let i = 0; i < newConcepts.length; i++) {\n          const yOffset = (i - 2) * 100; // -200, -100, 0, 100, 200\n          newPositions[`expanded-${index}-${i}`] = {\n            x: parentPos.x + 250,\n            y: parentPos.y + yOffset\n          };\n        }\n        break;\n        \n      case 'bottom-left':\n        // Arrange horizontally below and to the left\n        for (let i = 0; i < newConcepts.length; i++) {\n          const xOffset = (i - 2) * 120; // -240, -120, 0, 120, 240\n          newPositions[`expanded-${index}-${i}`] = {\n            x: parentPos.x - 100 + xOffset,\n            y: parentPos.y + 150\n          };\n        }\n        break;\n        \n      case 'bottom-right':\n        // Arrange horizontally below and to the right\n        for (let i = 0; i < newConcepts.length; i++) {\n          const xOffset = (i - 2) * 120; // -240, -120, 0, 120, 240\n          newPositions[`expanded-${index}-${i}`] = {\n            x: parentPos.x + 100 + xOffset,\n            y: parentPos.y + 150\n          };\n        }\n        break;\n    }\n    \n    setPositions(newPositions);\n  };\n\n  // Toggle node active state\n  const toggleNodeActive = (index) => {\n    // Count how many inactive nodes we currently have\n    const inactiveCount = activeNodes.filter(active => !active).length;\n    \n    // If this node is already inactive, we can always make it active again\n    if (!activeNodes[index]) {\n      setActiveNodes(prev => {\n        const newActive = [...prev];\n        newActive[index] = true;\n        return newActive;\n      });\n      // If we're activating a node, clear expansion\n      if (expandedNodeIndex !== null) {\n        setExpandedNodeIndex(null);\n        setExpandedConcepts([]);\n      }\n      return;\n    }\n    \n    // If this would be the 5th inactive node (all inactive), don't allow it\n    if (inactiveCount === 4) {\n      // Find the only remaining active node (which must be this one)\n      const activeNodeIndices = activeNodes.map((active, i) => active ? i : -1).filter(i => i >= 0);\n      if (activeNodeIndices.length === 1 && activeNodeIndices[0] === index) {\n        console.log(\"Can't deactivate the last node\");\n        return;\n      }\n    }\n    \n    // Make this node inactive\n    setActiveNodes(prev => {\n      const newActive = [...prev];\n      newActive[index] = false;\n      return newActive;\n    });\n    \n    // Check if we now have 4 inactive nodes (1 active)\n    const newInactiveCount = inactiveCount + 1;\n    if (newInactiveCount === 4) {\n      // Find the one remaining active node\n      const remainingActiveIndex = activeNodes.findIndex((active, i) => active && i !== index);\n      if (remainingActiveIndex !== -1) {\n        // Expand the remaining active node\n        expandNode(remainingActiveIndex);\n      }\n    }\n  };\n  \n  // Handle starting to drag a concept\n  const handleMouseDown = (e, conceptId) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    const rect = e.currentTarget.getBoundingClientRect();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    \n    setDraggedConcept(conceptId);\n    setDragOffset({\n      x: e.clientX - (rect.left - mapRect.left),\n      y: e.clientY - (rect.top - mapRect.top)\n    });\n    \n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n  };\n\n  // Handle dragging a concept\n  const handleMouseMove = (e) => {\n    if (!draggedConcept) return;\n    \n    e.preventDefault();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    const newX = e.clientX - mapRect.left - dragOffset.x;\n    const newY = e.clientY - mapRect.top - dragOffset.y;\n\n    setPositions(prev => ({\n      ...prev,\n      [draggedConcept]: { x: newX, y: newY }\n    }));\n  };\n\n  // Handle dropping a concept\n  const handleMouseUp = () => {\n    setDraggedConcept(null);\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('mouseup', handleMouseUp);\n  };\n\n  // Render connection lines between central node and concepts\n  const renderConnections = () => {\n    const mapRect = mapRef.current?.getBoundingClientRect();\n    const centralRect = centralRef.current?.getBoundingClientRect();\n    \n    if (!mapRect || !centralRect) return null;\n    \n    // The exact center of the central question box\n    const centerX = mapRect.width / 2;\n    const centerY = mapRect.height / 2;\n    \n    const connections = [];\n    \n    // Render connections to main concepts\n    concepts.forEach((_, index) => {\n      const pos = positions[`concept-${index}`];\n      if (!pos) return;\n      \n      // Calculate the exact center position of the concept\n      const conceptCenterX = centerX + pos.x;\n      const conceptCenterY = centerY + pos.y;\n      \n      connections.push(\n        <line\n          key={`line-${index}`}\n          x1={centerX}\n          y1={centerY}\n          x2={conceptCenterX}\n          y2={conceptCenterY}\n          className={activeNodes[index] ? 'connection' : 'connection inactive'}\n        />\n      );\n      \n      // If this is the expanded node, add connections to expanded concepts\n      if (index === expandedNodeIndex) {\n        expandedConcepts.forEach((_, i) => {\n          const expandedPos = positions[`expanded-${index}-${i}`];\n          if (!expandedPos) return;\n          \n          const expandedX = centerX + expandedPos.x;\n          const expandedY = centerY + expandedPos.y;\n          \n          connections.push(\n            <line\n              key={`expanded-line-${index}-${i}`}\n              x1={conceptCenterX}\n              y1={conceptCenterY}\n              x2={expandedX}\n              y2={expandedY}\n              className=\"connection expanded\"\n            />\n          );\n        });\n      }\n    });\n    \n    return connections;\n  };\n\n  // Console log for debugging\n  console.log(\"Active nodes:\", activeNodes);\n  console.log(\"Expanded node index:\", expandedNodeIndex);\n  console.log(\"Expanded concepts:\", expandedConcepts);\n  console.log(\"Positions:\", positions);\n\n  return (\n    <div className=\"mind-map-container\">\n      <div className=\"mind-map\" ref={mapRef}>\n        {/* SVG for the connections between nodes */}\n        <svg className=\"connections\">\n          {mapRef.current && centralRef.current && renderConnections()}\n        </svg>\n        \n        {/* Central Question Node */}\n        <div className=\"central-question\" ref={centralRef}>\n          {centralQuestion}\n        </div>\n        \n        {/* Concept Nodes */}\n        {concepts.map((concept, index) => {\n          const pos = positions[`concept-${index}`] || { x: 0, y: 0 };\n          const isDragging = draggedConcept === `concept-${index}`;\n          \n          return (\n            <div\n              key={index}\n              className={`concept ${!activeNodes[index] ? 'inactive' : ''} ${isDragging ? 'dragging' : ''} ${index === expandedNodeIndex ? 'expanded' : ''}`}\n              style={{\n                top: `calc(50% + ${pos.y}px)`,\n                left: `calc(50% + ${pos.x}px)`,\n                transform: 'translate(-50%, -50%)',\n                cursor: isDragging ? 'grabbing' : 'grab'\n              }}\n              ref={conceptRefs.current[index]}\n              onMouseDown={(e) => handleMouseDown(e, `concept-${index}`)}\n              onClick={(e) => {\n                e.stopPropagation();\n                if (!draggedConcept) {\n                  toggleNodeActive(index);\n                }\n              }}\n            >\n              {concept}\n            </div>\n          );\n        })}\n        \n        {/* Expanded Concept Nodes */}\n        {expandedNodeIndex !== null && expandedConcepts.map((concept, index) => {\n          const pos = positions[`expanded-${expandedNodeIndex}-${index}`];\n          if (!pos) return null;\n          \n          // Add debug border for visibility\n          return (\n            <div\n              key={`expanded-${expandedNodeIndex}-${index}`}\n              className=\"concept expanded-child\"\n              style={{\n                top: `calc(50% + ${pos.y}px)`,\n                left: `calc(50% + ${pos.x}px)`,\n                transform: 'translate(-50%, -50%)',\n                border: '2px solid #000'\n              }}\n            >\n              {concept}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\nexport default MindMap; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}