{"ast":null,"code":"var _jsxFileName = \"/Users/kei/AIdeator-LLM/frontend/src/components/MindMap.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from 'react';\nimport './MindMap.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MindMap = ({\n  centralQuestion,\n  concepts\n}) => {\n  _s();\n  const [positions, setPositions] = useState({});\n  const [draggedConcept, setDraggedConcept] = useState(null);\n  const [dragOffset, setDragOffset] = useState({\n    x: 0,\n    y: 0\n  });\n  const [activeNodes, setActiveNodes] = useState(concepts.map((_, i) => true));\n  const [nodeRefs, setNodeRefs] = useState({});\n  const [paths, setPaths] = useState([]);\n  const mapRef = useRef(null);\n  const centralRef = useRef(null);\n\n  // Create refs for each concept node\n  useEffect(() => {\n    const refs = {};\n    concepts.forEach((_, index) => {\n      refs[`concept-${index}`] = /*#__PURE__*/React.createRef();\n    });\n    setNodeRefs(refs);\n  }, [concepts]);\n\n  // Initialize positions in a fixed pattern that matches the reference image\n  useEffect(() => {\n    if (Object.keys(positions).length === 0) {\n      const initialPositions = {\n        'concept-0': {\n          x: 0,\n          y: -180\n        },\n        // Top\n        'concept-1': {\n          x: 250,\n          y: 180\n        },\n        // Bottom Right\n        'concept-2': {\n          x: -250,\n          y: 180\n        },\n        // Bottom Left\n        'concept-3': {\n          x: 250,\n          y: -100\n        },\n        // Top Right\n        'concept-4': {\n          x: -250,\n          y: -100\n        } // Top Left\n      };\n      setPositions(initialPositions);\n    }\n  }, [positions]);\n\n  // Calculate connection paths when positions change\n  useEffect(() => {\n    if (!centralRef.current || !mapRef.current) return;\n    const calculatePaths = () => {\n      const mapRect = mapRef.current.getBoundingClientRect();\n      const centralRect = centralRef.current.getBoundingClientRect();\n\n      // Calculate paths between central question and concepts\n      const newPaths = concepts.map((_, index) => {\n        var _nodeRefs;\n        const nodeRef = (_nodeRefs = nodeRefs[`concept-${index}`]) === null || _nodeRefs === void 0 ? void 0 : _nodeRefs.current;\n        if (!nodeRef || !positions[`concept-${index}`]) return null;\n        const nodeRect = nodeRef.getBoundingClientRect();\n        const pos = positions[`concept-${index}`];\n\n        // Convert to center points\n        const centerX = mapRect.width / 2;\n        const centerY = mapRect.height / 2;\n        const centralWidth = centralRect.width;\n        const centralHeight = centralRect.height;\n        const conceptWidth = nodeRect.width;\n        const conceptHeight = nodeRect.height;\n\n        // Calculate angle between centers\n        const dx = pos.x;\n        const dy = pos.y;\n        const angle = Math.atan2(dy, dx);\n\n        // Find intersection points with the rectangles\n        let centralIntersectX, centralIntersectY, conceptIntersectX, conceptIntersectY;\n\n        // Central question intersection\n        if (Math.abs(Math.cos(angle)) < 0.001) {\n          // Vertical line\n          centralIntersectX = centerX;\n          centralIntersectY = centerY + Math.sign(dy) * (centralHeight / 2);\n        } else if (Math.abs(Math.sin(angle)) < 0.001) {\n          // Horizontal line\n          centralIntersectX = centerX + Math.sign(dx) * (centralWidth / 2);\n          centralIntersectY = centerY;\n        } else {\n          // Determine if intersection is with vertical or horizontal edge\n          const slope = Math.abs(dy / dx);\n          const centralAspect = centralHeight / centralWidth;\n          if (slope > centralAspect) {\n            // Intersect with top/bottom edge\n            centralIntersectY = centerY + Math.sign(dy) * (centralHeight / 2);\n            centralIntersectX = centerX + (centralIntersectY - centerY) / slope * Math.sign(dx);\n          } else {\n            // Intersect with left/right edge\n            centralIntersectX = centerX + Math.sign(dx) * (centralWidth / 2);\n            centralIntersectY = centerY + slope * (centralIntersectX - centerX) * Math.sign(dy);\n          }\n        }\n\n        // Concept box intersection (opposite angle)\n        const conceptCenterX = centerX + pos.x;\n        const conceptCenterY = centerY + pos.y;\n        if (Math.abs(Math.cos(angle)) < 0.001) {\n          // Vertical line\n          conceptIntersectX = conceptCenterX;\n          conceptIntersectY = conceptCenterY - Math.sign(dy) * (conceptHeight / 2);\n        } else if (Math.abs(Math.sin(angle)) < 0.001) {\n          // Horizontal line\n          conceptIntersectX = conceptCenterX - Math.sign(dx) * (conceptWidth / 2);\n          conceptIntersectY = conceptCenterY;\n        } else {\n          // Determine if intersection is with vertical or horizontal edge\n          const slope = Math.abs(dy / dx);\n          const conceptAspect = conceptHeight / conceptWidth;\n          if (slope > conceptAspect) {\n            // Intersect with top/bottom edge\n            conceptIntersectY = conceptCenterY - Math.sign(dy) * (conceptHeight / 2);\n            conceptIntersectX = conceptCenterX - (conceptCenterY - conceptIntersectY) / slope * Math.sign(dx);\n          } else {\n            // Intersect with left/right edge\n            conceptIntersectX = conceptCenterX - Math.sign(dx) * (conceptWidth / 2);\n            conceptIntersectY = conceptCenterY - slope * (conceptCenterX - conceptIntersectX) * Math.sign(dy);\n          }\n        }\n        return {\n          id: index,\n          points: {\n            centralX: centralIntersectX,\n            centralY: centralIntersectY,\n            conceptX: conceptIntersectX,\n            conceptY: conceptIntersectY\n          },\n          active: activeNodes[index]\n        };\n      });\n      setPaths(newPaths.filter(Boolean));\n    };\n\n    // Call immediately\n    calculatePaths();\n\n    // And set up a window resize listener for responsive updates\n    window.addEventListener('resize', calculatePaths);\n    return () => window.removeEventListener('resize', calculatePaths);\n  }, [positions, nodeRefs, concepts, activeNodes]);\n\n  // Handle starting to drag a concept\n  const handleMouseDown = (e, conceptId) => {\n    e.preventDefault();\n    e.stopPropagation();\n    const rect = e.currentTarget.getBoundingClientRect();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    setDraggedConcept(conceptId);\n    setDragOffset({\n      x: e.clientX - (rect.left - mapRect.left),\n      y: e.clientY - (rect.top - mapRect.top)\n    });\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n  };\n\n  // Handle dragging a concept\n  const handleMouseMove = e => {\n    if (!draggedConcept) return;\n    e.preventDefault();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    const newX = e.clientX - mapRect.left - dragOffset.x;\n    const newY = e.clientY - mapRect.top - dragOffset.y;\n    setPositions(prev => ({\n      ...prev,\n      [draggedConcept]: {\n        x: newX,\n        y: newY\n      }\n    }));\n  };\n\n  // Handle dropping a concept\n  const handleMouseUp = () => {\n    setDraggedConcept(null);\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('mouseup', handleMouseUp);\n  };\n\n  // Toggle active/inactive state of a concept when clicked\n  const handleConceptClick = index => {\n    if (draggedConcept) return; // Don't toggle if we're dragging\n\n    setActiveNodes(prev => {\n      const newActiveNodes = [...prev];\n      newActiveNodes[index] = !newActiveNodes[index];\n      return newActiveNodes;\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"mind-map-container\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mind-map\",\n      ref: mapRef,\n      children: [/*#__PURE__*/_jsxDEV(\"svg\", {\n        className: \"connections\",\n        children: paths.map(path => /*#__PURE__*/_jsxDEV(\"line\", {\n          x1: path.points.centralX,\n          y1: path.points.centralY,\n          x2: path.points.conceptX,\n          y2: path.points.conceptY,\n          className: !path.active ? 'connection inactive' : 'connection'\n        }, `line-${path.id}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 207,\n          columnNumber: 13\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 205,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"central-question\",\n        ref: centralRef,\n        children: centralQuestion\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 218,\n        columnNumber: 9\n      }, this), concepts.map((concept, index) => {\n        const pos = positions[`concept-${index}`] || {\n          x: 0,\n          y: 0\n        };\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `concept ${!activeNodes[index] ? 'inactive' : ''} ${draggedConcept === `concept-${index}` ? 'dragging' : ''}`,\n          style: {\n            transform: `translate(calc(50% + ${pos.x}px), calc(50% + ${pos.y}px))`,\n            cursor: draggedConcept === `concept-${index}` ? 'grabbing' : 'grab'\n          },\n          ref: nodeRefs[`concept-${index}`],\n          onMouseDown: e => handleMouseDown(e, `concept-${index}`),\n          onClick: () => handleConceptClick(index),\n          children: concept\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 225,\n          columnNumber: 13\n        }, this);\n      })]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 201,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 200,\n    columnNumber: 5\n  }, this);\n};\n_s(MindMap, \"P9zVbiVo7QZsZbFOTTSnJ14CHrI=\");\n_c = MindMap;\nexport default MindMap;\nvar _c;\n$RefreshReg$(_c, \"MindMap\");","map":{"version":3,"names":["React","useState","useRef","useEffect","jsxDEV","_jsxDEV","MindMap","centralQuestion","concepts","_s","positions","setPositions","draggedConcept","setDraggedConcept","dragOffset","setDragOffset","x","y","activeNodes","setActiveNodes","map","_","i","nodeRefs","setNodeRefs","paths","setPaths","mapRef","centralRef","refs","forEach","index","createRef","Object","keys","length","initialPositions","current","calculatePaths","mapRect","getBoundingClientRect","centralRect","newPaths","_nodeRefs","nodeRef","nodeRect","pos","centerX","width","centerY","height","centralWidth","centralHeight","conceptWidth","conceptHeight","dx","dy","angle","Math","atan2","centralIntersectX","centralIntersectY","conceptIntersectX","conceptIntersectY","abs","cos","sign","sin","slope","centralAspect","conceptCenterX","conceptCenterY","conceptAspect","id","points","centralX","centralY","conceptX","conceptY","active","filter","Boolean","window","addEventListener","removeEventListener","handleMouseDown","e","conceptId","preventDefault","stopPropagation","rect","currentTarget","clientX","left","clientY","top","document","handleMouseMove","handleMouseUp","newX","newY","prev","handleConceptClick","newActiveNodes","className","children","ref","path","x1","y1","x2","y2","fileName","_jsxFileName","lineNumber","columnNumber","concept","style","transform","cursor","onMouseDown","onClick","_c","$RefreshReg$"],"sources":["/Users/kei/AIdeator-LLM/frontend/src/components/MindMap.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\nimport './MindMap.css';\n\nconst MindMap = ({ centralQuestion, concepts }) => {\n  const [positions, setPositions] = useState({});\n  const [draggedConcept, setDraggedConcept] = useState(null);\n  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });\n  const [activeNodes, setActiveNodes] = useState(concepts.map((_, i) => true));\n  const [nodeRefs, setNodeRefs] = useState({});\n  const [paths, setPaths] = useState([]);\n  const mapRef = useRef(null);\n  const centralRef = useRef(null);\n\n  // Create refs for each concept node\n  useEffect(() => {\n    const refs = {};\n    concepts.forEach((_, index) => {\n      refs[`concept-${index}`] = React.createRef();\n    });\n    setNodeRefs(refs);\n  }, [concepts]);\n\n  // Initialize positions in a fixed pattern that matches the reference image\n  useEffect(() => {\n    if (Object.keys(positions).length === 0) {\n      const initialPositions = {\n        'concept-0': { x: 0, y: -180 },     // Top\n        'concept-1': { x: 250, y: 180 },    // Bottom Right\n        'concept-2': { x: -250, y: 180 },   // Bottom Left\n        'concept-3': { x: 250, y: -100 },   // Top Right\n        'concept-4': { x: -250, y: -100 }   // Top Left\n      };\n      \n      setPositions(initialPositions);\n    }\n  }, [positions]);\n\n  // Calculate connection paths when positions change\n  useEffect(() => {\n    if (!centralRef.current || !mapRef.current) return;\n    \n    const calculatePaths = () => {\n      const mapRect = mapRef.current.getBoundingClientRect();\n      const centralRect = centralRef.current.getBoundingClientRect();\n      \n      // Calculate paths between central question and concepts\n      const newPaths = concepts.map((_, index) => {\n        const nodeRef = nodeRefs[`concept-${index}`]?.current;\n        if (!nodeRef || !positions[`concept-${index}`]) return null;\n        \n        const nodeRect = nodeRef.getBoundingClientRect();\n        const pos = positions[`concept-${index}`];\n        \n        // Convert to center points\n        const centerX = mapRect.width / 2;\n        const centerY = mapRect.height / 2;\n        \n        const centralWidth = centralRect.width;\n        const centralHeight = centralRect.height;\n        \n        const conceptWidth = nodeRect.width;\n        const conceptHeight = nodeRect.height;\n        \n        // Calculate angle between centers\n        const dx = pos.x;\n        const dy = pos.y;\n        const angle = Math.atan2(dy, dx);\n        \n        // Find intersection points with the rectangles\n        let centralIntersectX, centralIntersectY, conceptIntersectX, conceptIntersectY;\n        \n        // Central question intersection\n        if (Math.abs(Math.cos(angle)) < 0.001) {\n          // Vertical line\n          centralIntersectX = centerX;\n          centralIntersectY = centerY + Math.sign(dy) * (centralHeight / 2);\n        } else if (Math.abs(Math.sin(angle)) < 0.001) {\n          // Horizontal line\n          centralIntersectX = centerX + Math.sign(dx) * (centralWidth / 2);\n          centralIntersectY = centerY;\n        } else {\n          // Determine if intersection is with vertical or horizontal edge\n          const slope = Math.abs(dy / dx);\n          const centralAspect = centralHeight / centralWidth;\n          \n          if (slope > centralAspect) {\n            // Intersect with top/bottom edge\n            centralIntersectY = centerY + Math.sign(dy) * (centralHeight / 2);\n            centralIntersectX = centerX + (centralIntersectY - centerY) / slope * Math.sign(dx);\n          } else {\n            // Intersect with left/right edge\n            centralIntersectX = centerX + Math.sign(dx) * (centralWidth / 2);\n            centralIntersectY = centerY + slope * (centralIntersectX - centerX) * Math.sign(dy);\n          }\n        }\n        \n        // Concept box intersection (opposite angle)\n        const conceptCenterX = centerX + pos.x;\n        const conceptCenterY = centerY + pos.y;\n        \n        if (Math.abs(Math.cos(angle)) < 0.001) {\n          // Vertical line\n          conceptIntersectX = conceptCenterX;\n          conceptIntersectY = conceptCenterY - Math.sign(dy) * (conceptHeight / 2);\n        } else if (Math.abs(Math.sin(angle)) < 0.001) {\n          // Horizontal line\n          conceptIntersectX = conceptCenterX - Math.sign(dx) * (conceptWidth / 2);\n          conceptIntersectY = conceptCenterY;\n        } else {\n          // Determine if intersection is with vertical or horizontal edge\n          const slope = Math.abs(dy / dx);\n          const conceptAspect = conceptHeight / conceptWidth;\n          \n          if (slope > conceptAspect) {\n            // Intersect with top/bottom edge\n            conceptIntersectY = conceptCenterY - Math.sign(dy) * (conceptHeight / 2);\n            conceptIntersectX = conceptCenterX - (conceptCenterY - conceptIntersectY) / slope * Math.sign(dx);\n          } else {\n            // Intersect with left/right edge\n            conceptIntersectX = conceptCenterX - Math.sign(dx) * (conceptWidth / 2);\n            conceptIntersectY = conceptCenterY - slope * (conceptCenterX - conceptIntersectX) * Math.sign(dy);\n          }\n        }\n        \n        return {\n          id: index,\n          points: {\n            centralX: centralIntersectX,\n            centralY: centralIntersectY,\n            conceptX: conceptIntersectX,\n            conceptY: conceptIntersectY\n          },\n          active: activeNodes[index]\n        };\n      });\n      \n      setPaths(newPaths.filter(Boolean));\n    };\n    \n    // Call immediately\n    calculatePaths();\n    \n    // And set up a window resize listener for responsive updates\n    window.addEventListener('resize', calculatePaths);\n    return () => window.removeEventListener('resize', calculatePaths);\n  }, [positions, nodeRefs, concepts, activeNodes]);\n\n  // Handle starting to drag a concept\n  const handleMouseDown = (e, conceptId) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    const rect = e.currentTarget.getBoundingClientRect();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    \n    setDraggedConcept(conceptId);\n    setDragOffset({\n      x: e.clientX - (rect.left - mapRect.left),\n      y: e.clientY - (rect.top - mapRect.top)\n    });\n    \n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n  };\n\n  // Handle dragging a concept\n  const handleMouseMove = (e) => {\n    if (!draggedConcept) return;\n    \n    e.preventDefault();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    const newX = e.clientX - mapRect.left - dragOffset.x;\n    const newY = e.clientY - mapRect.top - dragOffset.y;\n\n    setPositions(prev => ({\n      ...prev,\n      [draggedConcept]: { x: newX, y: newY }\n    }));\n  };\n\n  // Handle dropping a concept\n  const handleMouseUp = () => {\n    setDraggedConcept(null);\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('mouseup', handleMouseUp);\n  };\n\n  // Toggle active/inactive state of a concept when clicked\n  const handleConceptClick = (index) => {\n    if (draggedConcept) return; // Don't toggle if we're dragging\n    \n    setActiveNodes(prev => {\n      const newActiveNodes = [...prev];\n      newActiveNodes[index] = !newActiveNodes[index];\n      return newActiveNodes;\n    });\n  };\n\n  return (\n    <div className=\"mind-map-container\">\n      <div \n        className=\"mind-map\" \n        ref={mapRef}\n      >\n        <svg className=\"connections\">\n          {paths.map(path => (\n            <line\n              key={`line-${path.id}`}\n              x1={path.points.centralX}\n              y1={path.points.centralY}\n              x2={path.points.conceptX}\n              y2={path.points.conceptY}\n              className={!path.active ? 'connection inactive' : 'connection'}\n            />\n          ))}\n        </svg>\n        \n        <div className=\"central-question\" ref={centralRef}>\n          {centralQuestion}\n        </div>\n        \n        {concepts.map((concept, index) => {\n          const pos = positions[`concept-${index}`] || { x: 0, y: 0 };\n          return (\n            <div\n              key={index}\n              className={`concept ${!activeNodes[index] ? 'inactive' : ''} ${draggedConcept === `concept-${index}` ? 'dragging' : ''}`}\n              style={{\n                transform: `translate(calc(50% + ${pos.x}px), calc(50% + ${pos.y}px))`,\n                cursor: draggedConcept === `concept-${index}` ? 'grabbing' : 'grab'\n              }}\n              ref={nodeRefs[`concept-${index}`]}\n              onMouseDown={(e) => handleMouseDown(e, `concept-${index}`)}\n              onClick={() => handleConceptClick(index)}\n            >\n              {concept}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\nexport default MindMap; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}