{"ast":null,"code":"var _jsxFileName = \"/Users/kei/AIdeator-LLM/frontend/src/components/MindMap.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from 'react';\nimport './MindMap.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MindMap = ({\n  centralQuestion,\n  concepts\n}) => {\n  _s();\n  const [positions, setPositions] = useState({});\n  const [draggedConcept, setDraggedConcept] = useState(null);\n  const [dragOffset, setDragOffset] = useState({\n    x: 0,\n    y: 0\n  });\n  const [activeNodes, setActiveNodes] = useState(concepts.map((_, i) => true));\n  const [nodeRefs, setNodeRefs] = useState({});\n  const [lines, setLines] = useState([]);\n  const mapRef = useRef(null);\n  const centralRef = useRef(null);\n\n  // Create refs for each concept node\n  useEffect(() => {\n    const refs = {};\n    concepts.forEach((_, index) => {\n      refs[`concept-${index}`] = /*#__PURE__*/React.createRef();\n    });\n    setNodeRefs(refs);\n  }, [concepts]);\n\n  // Initialize positions in a circular pattern around the center\n  useEffect(() => {\n    if (Object.keys(positions).length === 0) {\n      const initialPositions = {};\n\n      // Position concepts evenly in a circle around the central question\n      concepts.forEach((_, index) => {\n        const angle = 2 * Math.PI * index / concepts.length;\n        initialPositions[`concept-${index}`] = {\n          x: Math.cos(angle) * 300,\n          y: Math.sin(angle) * 200\n        };\n      });\n      setPositions(initialPositions);\n    }\n  }, [concepts, positions]);\n\n  // Calculate lines between central question and concepts\n  useEffect(() => {\n    if (!centralRef.current || !mapRef.current) return;\n    const mapRect = mapRef.current.getBoundingClientRect();\n    const centralRect = centralRef.current.getBoundingClientRect();\n\n    // Calculate center point of the central question\n    const centerX = mapRect.width / 2;\n    const centerY = mapRect.height / 2;\n\n    // Width and height of central question\n    const centralWidth = centralRect.width;\n    const centralHeight = centralRect.height;\n    const newLines = concepts.map((_, index) => {\n      var _nodeRefs;\n      const nodeRef = (_nodeRefs = nodeRefs[`concept-${index}`]) === null || _nodeRefs === void 0 ? void 0 : _nodeRefs.current;\n      if (!nodeRef) return null;\n      const pos = positions[`concept-${index}`];\n      if (!pos) return null;\n      const nodeRect = nodeRef.getBoundingClientRect();\n\n      // Calculate the angle between central question and concept\n      const dx = pos.x;\n      const dy = pos.y;\n      const angle = Math.atan2(dy, dx);\n\n      // Calculate intersection point with central question box\n      let centralEndX, centralEndY;\n\n      // Handle zero or near-zero angles to prevent NaN\n      if (Math.abs(dx) < 0.001) {\n        // Vertical line\n        centralEndX = centerX;\n        centralEndY = centerY + Math.sign(dy) * centralHeight / 2;\n      } else if (Math.abs(dy) < 0.001) {\n        // Horizontal line\n        centralEndX = centerX + Math.sign(dx) * centralWidth / 2;\n        centralEndY = centerY;\n      } else if (Math.abs(Math.cos(angle)) * centralHeight > Math.abs(Math.sin(angle)) * centralWidth) {\n        // Line intersects left or right edge of central box\n        centralEndX = centerX + Math.sign(Math.cos(angle)) * centralWidth / 2;\n        centralEndY = centerY + Math.tan(angle) * Math.sign(Math.cos(angle)) * centralWidth / 2;\n      } else {\n        // Line intersects top or bottom edge of central box\n        const cotAngle = Math.cos(angle) / Math.sin(angle);\n        centralEndX = centerX + cotAngle * Math.sign(Math.sin(angle)) * centralHeight / 2;\n        centralEndY = centerY + Math.sign(Math.sin(angle)) * centralHeight / 2;\n      }\n\n      // Calculate the position of the concept center relative to map\n      const conceptCenterX = centerX + pos.x;\n      const conceptCenterY = centerY + pos.y;\n\n      // Width and height of concept\n      const conceptWidth = nodeRect.width;\n      const conceptHeight = nodeRect.height;\n\n      // Calculate intersection point with concept box\n      let conceptEndX, conceptEndY;\n\n      // Handle zero or near-zero angles to prevent NaN\n      if (Math.abs(dx) < 0.001) {\n        // Vertical line\n        conceptEndX = conceptCenterX;\n        conceptEndY = conceptCenterY - Math.sign(dy) * conceptHeight / 2;\n      } else if (Math.abs(dy) < 0.001) {\n        // Horizontal line\n        conceptEndX = conceptCenterX - Math.sign(dx) * conceptWidth / 2;\n        conceptEndY = conceptCenterY;\n      } else if (Math.abs(Math.cos(angle)) * conceptHeight > Math.abs(Math.sin(angle)) * conceptWidth) {\n        // Line intersects left or right edge of concept box\n        conceptEndX = conceptCenterX - Math.sign(Math.cos(angle)) * conceptWidth / 2;\n        conceptEndY = conceptCenterY - Math.tan(angle) * Math.sign(Math.cos(angle)) * conceptWidth / 2;\n      } else {\n        // Line intersects top or bottom edge of concept box\n        const cotAngle = Math.cos(angle) / Math.sin(angle);\n        conceptEndX = conceptCenterX - cotAngle * Math.sign(Math.sin(angle)) * conceptHeight / 2;\n        conceptEndY = conceptCenterY - Math.sign(Math.sin(angle)) * conceptHeight / 2;\n      }\n\n      // Use a simpler approach for very specific angles to enhance stability\n      if (isNaN(centralEndX) || isNaN(centralEndY) || isNaN(conceptEndX) || isNaN(conceptEndY)) {\n        const adjustedAngle = angle % (Math.PI * 2);\n        if (adjustedAngle === 0 || Math.abs(adjustedAngle - Math.PI) < 0.001) {\n          // Horizontal line\n          centralEndX = centerX + Math.sign(dx) * centralWidth / 2;\n          centralEndY = centerY;\n          conceptEndX = conceptCenterX - Math.sign(dx) * conceptWidth / 2;\n          conceptEndY = conceptCenterY;\n        } else if (Math.abs(adjustedAngle - Math.PI / 2) < 0.001 || Math.abs(adjustedAngle - Math.PI * 3 / 2) < 0.001) {\n          // Vertical line\n          centralEndX = centerX;\n          centralEndY = centerY + Math.sign(dy) * centralHeight / 2;\n          conceptEndX = conceptCenterX;\n          conceptEndY = conceptCenterY - Math.sign(dy) * conceptHeight / 2;\n        }\n      }\n      return {\n        centralX: centralEndX,\n        centralY: centralEndY,\n        conceptX: conceptEndX,\n        conceptY: conceptEndY,\n        active: activeNodes[index]\n      };\n    });\n    setLines(newLines.filter(Boolean));\n  }, [positions, nodeRefs, concepts, activeNodes]);\n\n  // Handle starting to drag a concept\n  const handleMouseDown = (e, conceptId) => {\n    e.preventDefault();\n    e.stopPropagation();\n    const rect = e.currentTarget.getBoundingClientRect();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    setDraggedConcept(conceptId);\n    setDragOffset({\n      x: e.clientX - (rect.left - mapRect.left),\n      y: e.clientY - (rect.top - mapRect.top)\n    });\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n  };\n\n  // Handle dragging a concept\n  const handleMouseMove = e => {\n    if (!draggedConcept) return;\n    e.preventDefault();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    const newX = e.clientX - mapRect.left - dragOffset.x;\n    const newY = e.clientY - mapRect.top - dragOffset.y;\n    setPositions(prev => ({\n      ...prev,\n      [draggedConcept]: {\n        x: newX,\n        y: newY\n      }\n    }));\n  };\n\n  // Handle dropping a concept\n  const handleMouseUp = () => {\n    setDraggedConcept(null);\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('mouseup', handleMouseUp);\n  };\n\n  // Toggle active/inactive state of a concept when clicked\n  const handleConceptClick = index => {\n    if (draggedConcept) return; // Don't toggle if we're dragging\n\n    setActiveNodes(prev => {\n      const newActiveNodes = [...prev];\n      newActiveNodes[index] = !newActiveNodes[index];\n      return newActiveNodes;\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"mind-map-container\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mind-map\",\n      ref: mapRef,\n      children: [/*#__PURE__*/_jsxDEV(\"svg\", {\n        className: \"connections\",\n        children: lines.map((line, index) => /*#__PURE__*/_jsxDEV(\"line\", {\n          x1: line.centralX,\n          y1: line.centralY,\n          x2: line.conceptX,\n          y2: line.conceptY,\n          className: !line.active ? 'connection inactive' : 'connection'\n        }, `line-${index}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 213,\n          columnNumber: 13\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 211,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"central-question\",\n        ref: centralRef,\n        children: centralQuestion\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 224,\n        columnNumber: 9\n      }, this), concepts.map((concept, index) => {\n        const pos = positions[`concept-${index}`] || {\n          x: 0,\n          y: 0\n        };\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `concept ${!activeNodes[index] ? 'inactive' : ''} ${draggedConcept === `concept-${index}` ? 'dragging' : ''}`,\n          style: {\n            transform: `translate(calc(50% + ${pos.x}px), calc(50% + ${pos.y}px))`,\n            cursor: draggedConcept === `concept-${index}` ? 'grabbing' : 'grab'\n          },\n          ref: nodeRefs[`concept-${index}`],\n          onMouseDown: e => handleMouseDown(e, `concept-${index}`),\n          onClick: () => handleConceptClick(index),\n          children: concept\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 231,\n          columnNumber: 13\n        }, this);\n      })]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 207,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 206,\n    columnNumber: 5\n  }, this);\n};\n_s(MindMap, \"AMqojTg2D7CA9VV7DoGgjxdpoDI=\");\n_c = MindMap;\nexport default MindMap;\nvar _c;\n$RefreshReg$(_c, \"MindMap\");","map":{"version":3,"names":["React","useState","useRef","useEffect","jsxDEV","_jsxDEV","MindMap","centralQuestion","concepts","_s","positions","setPositions","draggedConcept","setDraggedConcept","dragOffset","setDragOffset","x","y","activeNodes","setActiveNodes","map","_","i","nodeRefs","setNodeRefs","lines","setLines","mapRef","centralRef","refs","forEach","index","createRef","Object","keys","length","initialPositions","angle","Math","PI","cos","sin","current","mapRect","getBoundingClientRect","centralRect","centerX","width","centerY","height","centralWidth","centralHeight","newLines","_nodeRefs","nodeRef","pos","nodeRect","dx","dy","atan2","centralEndX","centralEndY","abs","sign","tan","cotAngle","conceptCenterX","conceptCenterY","conceptWidth","conceptHeight","conceptEndX","conceptEndY","isNaN","adjustedAngle","centralX","centralY","conceptX","conceptY","active","filter","Boolean","handleMouseDown","e","conceptId","preventDefault","stopPropagation","rect","currentTarget","clientX","left","clientY","top","document","addEventListener","handleMouseMove","handleMouseUp","newX","newY","prev","removeEventListener","handleConceptClick","newActiveNodes","className","children","ref","line","x1","y1","x2","y2","fileName","_jsxFileName","lineNumber","columnNumber","concept","style","transform","cursor","onMouseDown","onClick","_c","$RefreshReg$"],"sources":["/Users/kei/AIdeator-LLM/frontend/src/components/MindMap.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\nimport './MindMap.css';\n\nconst MindMap = ({ centralQuestion, concepts }) => {\n  const [positions, setPositions] = useState({});\n  const [draggedConcept, setDraggedConcept] = useState(null);\n  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });\n  const [activeNodes, setActiveNodes] = useState(concepts.map((_, i) => true));\n  const [nodeRefs, setNodeRefs] = useState({});\n  const [lines, setLines] = useState([]);\n  const mapRef = useRef(null);\n  const centralRef = useRef(null);\n\n  // Create refs for each concept node\n  useEffect(() => {\n    const refs = {};\n    concepts.forEach((_, index) => {\n      refs[`concept-${index}`] = React.createRef();\n    });\n    setNodeRefs(refs);\n  }, [concepts]);\n\n  // Initialize positions in a circular pattern around the center\n  useEffect(() => {\n    if (Object.keys(positions).length === 0) {\n      const initialPositions = {};\n      \n      // Position concepts evenly in a circle around the central question\n      concepts.forEach((_, index) => {\n        const angle = (2 * Math.PI * index) / concepts.length;\n        initialPositions[`concept-${index}`] = {\n          x: Math.cos(angle) * 300,\n          y: Math.sin(angle) * 200\n        };\n      });\n      \n      setPositions(initialPositions);\n    }\n  }, [concepts, positions]);\n\n  // Calculate lines between central question and concepts\n  useEffect(() => {\n    if (!centralRef.current || !mapRef.current) return;\n    \n    const mapRect = mapRef.current.getBoundingClientRect();\n    const centralRect = centralRef.current.getBoundingClientRect();\n    \n    // Calculate center point of the central question\n    const centerX = mapRect.width / 2;\n    const centerY = mapRect.height / 2;\n    \n    // Width and height of central question\n    const centralWidth = centralRect.width;\n    const centralHeight = centralRect.height;\n    \n    const newLines = concepts.map((_, index) => {\n      const nodeRef = nodeRefs[`concept-${index}`]?.current;\n      if (!nodeRef) return null;\n      \n      const pos = positions[`concept-${index}`];\n      if (!pos) return null;\n      \n      const nodeRect = nodeRef.getBoundingClientRect();\n      \n      // Calculate the angle between central question and concept\n      const dx = pos.x;\n      const dy = pos.y;\n      const angle = Math.atan2(dy, dx);\n      \n      // Calculate intersection point with central question box\n      let centralEndX, centralEndY;\n      \n      // Handle zero or near-zero angles to prevent NaN\n      if (Math.abs(dx) < 0.001) {\n        // Vertical line\n        centralEndX = centerX;\n        centralEndY = centerY + Math.sign(dy) * centralHeight / 2;\n      } else if (Math.abs(dy) < 0.001) {\n        // Horizontal line\n        centralEndX = centerX + Math.sign(dx) * centralWidth / 2;\n        centralEndY = centerY;\n      } else if (Math.abs(Math.cos(angle)) * centralHeight > Math.abs(Math.sin(angle)) * centralWidth) {\n        // Line intersects left or right edge of central box\n        centralEndX = centerX + Math.sign(Math.cos(angle)) * centralWidth / 2;\n        centralEndY = centerY + Math.tan(angle) * Math.sign(Math.cos(angle)) * centralWidth / 2;\n      } else {\n        // Line intersects top or bottom edge of central box\n        const cotAngle = Math.cos(angle) / Math.sin(angle);\n        centralEndX = centerX + cotAngle * Math.sign(Math.sin(angle)) * centralHeight / 2;\n        centralEndY = centerY + Math.sign(Math.sin(angle)) * centralHeight / 2;\n      }\n      \n      // Calculate the position of the concept center relative to map\n      const conceptCenterX = centerX + pos.x;\n      const conceptCenterY = centerY + pos.y;\n      \n      // Width and height of concept\n      const conceptWidth = nodeRect.width;\n      const conceptHeight = nodeRect.height;\n      \n      // Calculate intersection point with concept box\n      let conceptEndX, conceptEndY;\n      \n      // Handle zero or near-zero angles to prevent NaN\n      if (Math.abs(dx) < 0.001) {\n        // Vertical line\n        conceptEndX = conceptCenterX;\n        conceptEndY = conceptCenterY - Math.sign(dy) * conceptHeight / 2;\n      } else if (Math.abs(dy) < 0.001) {\n        // Horizontal line\n        conceptEndX = conceptCenterX - Math.sign(dx) * conceptWidth / 2;\n        conceptEndY = conceptCenterY;\n      } else if (Math.abs(Math.cos(angle)) * conceptHeight > Math.abs(Math.sin(angle)) * conceptWidth) {\n        // Line intersects left or right edge of concept box\n        conceptEndX = conceptCenterX - Math.sign(Math.cos(angle)) * conceptWidth / 2;\n        conceptEndY = conceptCenterY - Math.tan(angle) * Math.sign(Math.cos(angle)) * conceptWidth / 2;\n      } else {\n        // Line intersects top or bottom edge of concept box\n        const cotAngle = Math.cos(angle) / Math.sin(angle);\n        conceptEndX = conceptCenterX - cotAngle * Math.sign(Math.sin(angle)) * conceptHeight / 2;\n        conceptEndY = conceptCenterY - Math.sign(Math.sin(angle)) * conceptHeight / 2;\n      }\n      \n      // Use a simpler approach for very specific angles to enhance stability\n      if (isNaN(centralEndX) || isNaN(centralEndY) || isNaN(conceptEndX) || isNaN(conceptEndY)) {\n        const adjustedAngle = angle % (Math.PI * 2);\n        if (adjustedAngle === 0 || Math.abs(adjustedAngle - Math.PI) < 0.001) {\n          // Horizontal line\n          centralEndX = centerX + Math.sign(dx) * centralWidth / 2;\n          centralEndY = centerY;\n          conceptEndX = conceptCenterX - Math.sign(dx) * conceptWidth / 2;\n          conceptEndY = conceptCenterY;\n        } else if (Math.abs(adjustedAngle - Math.PI/2) < 0.001 || Math.abs(adjustedAngle - Math.PI*3/2) < 0.001) {\n          // Vertical line\n          centralEndX = centerX;\n          centralEndY = centerY + Math.sign(dy) * centralHeight / 2;\n          conceptEndX = conceptCenterX;\n          conceptEndY = conceptCenterY - Math.sign(dy) * conceptHeight / 2;\n        }\n      }\n      \n      return {\n        centralX: centralEndX,\n        centralY: centralEndY,\n        conceptX: conceptEndX,\n        conceptY: conceptEndY,\n        active: activeNodes[index]\n      };\n    });\n    \n    setLines(newLines.filter(Boolean));\n  }, [positions, nodeRefs, concepts, activeNodes]);\n\n  // Handle starting to drag a concept\n  const handleMouseDown = (e, conceptId) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    const rect = e.currentTarget.getBoundingClientRect();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    \n    setDraggedConcept(conceptId);\n    setDragOffset({\n      x: e.clientX - (rect.left - mapRect.left),\n      y: e.clientY - (rect.top - mapRect.top)\n    });\n    \n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n  };\n\n  // Handle dragging a concept\n  const handleMouseMove = (e) => {\n    if (!draggedConcept) return;\n    \n    e.preventDefault();\n    const mapRect = mapRef.current.getBoundingClientRect();\n    const newX = e.clientX - mapRect.left - dragOffset.x;\n    const newY = e.clientY - mapRect.top - dragOffset.y;\n\n    setPositions(prev => ({\n      ...prev,\n      [draggedConcept]: { x: newX, y: newY }\n    }));\n  };\n\n  // Handle dropping a concept\n  const handleMouseUp = () => {\n    setDraggedConcept(null);\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('mouseup', handleMouseUp);\n  };\n\n  // Toggle active/inactive state of a concept when clicked\n  const handleConceptClick = (index) => {\n    if (draggedConcept) return; // Don't toggle if we're dragging\n    \n    setActiveNodes(prev => {\n      const newActiveNodes = [...prev];\n      newActiveNodes[index] = !newActiveNodes[index];\n      return newActiveNodes;\n    });\n  };\n\n  return (\n    <div className=\"mind-map-container\">\n      <div \n        className=\"mind-map\" \n        ref={mapRef}\n      >\n        <svg className=\"connections\">\n          {lines.map((line, index) => (\n            <line\n              key={`line-${index}`}\n              x1={line.centralX}\n              y1={line.centralY}\n              x2={line.conceptX}\n              y2={line.conceptY}\n              className={!line.active ? 'connection inactive' : 'connection'}\n            />\n          ))}\n        </svg>\n        \n        <div className=\"central-question\" ref={centralRef}>\n          {centralQuestion}\n        </div>\n        \n        {concepts.map((concept, index) => {\n          const pos = positions[`concept-${index}`] || { x: 0, y: 0 };\n          return (\n            <div\n              key={index}\n              className={`concept ${!activeNodes[index] ? 'inactive' : ''} ${draggedConcept === `concept-${index}` ? 'dragging' : ''}`}\n              style={{\n                transform: `translate(calc(50% + ${pos.x}px), calc(50% + ${pos.y}px))`,\n                cursor: draggedConcept === `concept-${index}` ? 'grabbing' : 'grab'\n              }}\n              ref={nodeRefs[`concept-${index}`]}\n              onMouseDown={(e) => handleMouseDown(e, `concept-${index}`)}\n              onClick={() => handleConceptClick(index)}\n            >\n              {concept}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\nexport default MindMap; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}